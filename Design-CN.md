# 一、选题背景

A\*（A-star）算法是一种在图搜索和路径规划领域广泛应用的高效算法。其主要优势在于能够在多个领域中找到最短路径，其中包括人工智能、游戏开发和机器人路径规划等。在这些领域，A\*算法不仅仅是一种理论上的算法，更是实际问题解决中的得力工具。
在游戏开发中，A\*算法为计算游戏中角色或单位的最短路径提供了可靠的解决方案。游戏地图作为一个图被抽象出来，A\*算法通过避开障碍物和不可行走的区域，帮助游戏中的角色高效地达到目标地点。这不仅提升了游戏玩家的体验，也为游戏开发者提供了强大的工具，使得游戏世界更具交互性和现实感；在机器人领域，A\*算法同样发挥着关键的作用。机器人需要在实际环境中规划运动路径，而 A\*算法通过考虑环境中的障碍物，利用传感器获取的信息，帮助机器人规划出避开障碍物、最短路径达到目标点的路径。这使得机器人在执行任务时更加智能、高效，提高了机器人在各种应用场景中的适应性和灵活性。
与 Dijkstra 算法不同，A\*算法的独特之处在于使用启发式函数来评估每个节点的优先级，从而更高效地找到最短路径。启发式函数通常基于从当前节点到终点的估算距离，如欧几里得距离或曼哈顿距离。此外，A\*算法的灵活性使得可以根据具体问题调整启发式函数，以进一步提高搜索效率和适应性。这使得 A\*算法成为解决实际问题中路径规划的首选算法之一，为各种应用场景提供了可靠的解决方案。

# 二、方案论证(设计理念)

市面上有很多种最短路径的实现方案，如 Dijkstra 算法、Bellman-Ford 算法、Floyd-Warshall 算法、最小生成树算法（Prim 算法和 Kruskal 算法）等。但是最终选择了使用 A\*算法进行实现，它结合了 Dijkstra 算法和贪心搜索的思想，使用启发式函数来评估每个节点的优先级，通过有针对性地搜索附近最有希望的节点，减少了搜索空间，并且能更高效地找到最短路径。A\*算法的适应性（Adaptability）也是让我选择这个方向的原因之一，A\*算法的启发式函数是可调整的，可以根据具体问题的特性进行调整，因此它非常适用于不同类型的图和路径规划问题，能够灵活应对不同的应用场景，因此，A\*算法在人工智能、游戏开发、机器人路径规划、地图导航等领域有广泛的应用，其成功的使用案例表明了算法的通用性和有效性。
显示的框架上我选择了 opencv，首先我首选的题目是第一个，设计思路是通过 opencv 进行图形处理后，建立图模型，最后运用最短路径算法进行，但是自己图像处理的代码水平不高，无法将图中的有效信息提取出来，而后面选择了题目 2，刚好配置好了 opencv 环境，使用 opencv 的图形绘制功能进行显示框架的的搭建，opencv 内置的鼠标事件调用也比较简单设置，仅仅需要配置回调函数的逻辑的即可完成基本任务，其图形窗口的坐标对于后续数据结构的转化也比较方便，并且对后续的扩展也能起一定的奠基作用；IDE 选用 visual studio 2022 社区版本，vs 能支持方便的断点调试，多源文件链接编译，还有强大的变量监视功能，能很高效的确认问题并及时调试修正。
整体方案可扩展性高，功能齐全稳定，算法效率高，后续维护成本低，代码结构清晰简洁，采用比较少量的代码就能实现比较全面的功能，同时可视化程度高，能很好展现 A\*算法的功能。
程序所有功能包括随机初始化地图（障碍物），可鼠标点击的自定义起点和重点，伪动画显示路径生成过程，可切换、自定义的障碍物，简单的计时功能，地图规模初始化，网格像素设置（适应屏幕分辨率），寻路失败处理。

# 三、过程论述

1. main 函数部分
   首先调用 gridInit 函数，传入 grids 和 grid_size 参数，对网格数组进行初始化。接着调用 generateObstacles 函数，传入 grids 参数，随机生成障碍物。然后，调用 drawGrid 函数，传入 image、grid_size、cell_size 和 grids 参数，将格子绘制在图像上，创建一个窗口，并绑定鼠标事件回调函数。
   进入主循环，不断执行以下的程序流程：
   调用 cv::waitKey 函数等待用户按键，返回按键的 ASCII 码。如果 startGrid 和 endGrid 都存在且 isSucess 为假，则调用 AStar4Way 函数，传入 startGrid、endGrid、grids 和 grid_size 参数，执行 A\*算法，将结果赋给 isSucess 变量。如果 isSucess 为真，则调用 AddAllRouteGridToVector 函数，传入 endGrid 和 route 参数，将路径上的所有网格放入 route 中。最后，调用 showRoute 函数，传入 image、grid_size、cell_size、grids 和 route 参数，显示路径。如果按下 ESC 键，则跳出循环。
   调用 cv::imshow 函数，显示图像，再调用 cv::destroyAllWindows 函数，销毁所有窗口，然后结束
2. onMouse 函数
   函数用来自定义设置终点，起点和障碍物，实现自定义的地图的功能，实现不同情况下算法的实现情况的对比。
   我先定义了一个静态的 startPt 和 endPt 变量，用来存储起点和终点的坐标。然后，代码通过判断 firstClick 的值来确定当前是设置起点还是终点。如果 firstClick 为 true，则表示当前是设置起点的阶段，如果为 false，则表示当前是设置终点的阶段。
   如果鼠标左键第一次点击，程序会计算鼠标点击位置所在的网格的行和列，并切换该网格的颜色。然后，代码通过 cv::rectangle 函数在图像上填充矩形框，来显示网格的颜色变化。最后，代码将 firstClick 设置为 false，表示已经完成了设置起点的操作，并将起点所在的网格设置为起点的网格。
   鼠标左键第二次被点击，代码会计算鼠标点击位置所在的网格的行和列，并切换该网格的颜色。程序通过 cv::rectangle 函数在图像上填充矩形框，以显示网格的颜色变化。将终点所在的网格设置为终点的网格，并关闭鼠标点击变换功能，即将回调函数设置为 NULL，以防止进一步的鼠标点击操作。
   同时，如果鼠标右键被点击，代码会计算鼠标点击位置所在的网格的行和列，并判断该网格是否已经被设置为障碍物。如果该网格不是障碍物，代码会在图像上填充矩形框，将该网格设置为障碍物，并改变矩形框的颜色。如果该网格已经是障碍物，代码会将该网格取消障碍物，并将矩形框的颜色改变回默认颜色。
3. AStar4Way 函数
   我首先定义了一些变量，包括 openGrid（表示 Open List，即待探索的节点集合）、closeGrid（表示 Close List，即已探索的节点集合）、current（表示当前正在计算的节点）。
   将起始节点 startGrid 放入 Open List。

   - 进入循环，直到 Open List 为空：
     - 找到 Open List 中 FCost 最小的节点作为当前节点 current。如果存在多个节点的 FCost 相同，则选择其中 HCost 最小的节点作为 current。
     - 将 current 从 Open List 中移除，并加入到 Close List 中。
     - 如果 current 是目标节点 endGrid，则寻路成功，返回 true。
       - 获取 current 的所有邻居节点（使用 FindAllNeighbors4Way 函数），对于每个邻居节点：
       - 如果邻居节点是墙或者已经在 Close List 或 Open List 中，则跳过。
     - 否则，将邻居节点的父节点设置为 current，并计算邻居节点的代价（使用 setCost4Way 函数），将邻居节点加入 Open List 中。
   - 如果 Open List 为空，则寻路失败，返回 false。

4. FindAllNeighbors4Way 函数
   函数用来找到当前节点的所有四连通邻居节点，也就是该点四个方向可以走的地方，用于辅助 A\*算法实现
   先定义了一个空的邻居节点集合 neighbors，最后将用于返回。
   获取当前节点 current 的索引，即当前节点在二维网格中的位置（currentX 和 currentY）。

   - 对于四个方向上的邻居节点：
   - 如果当前节点不在最上方，即 currentY 大于 0，则将上方邻居节点加入邻居节点集合。具体操作是通过计算上方邻居节点在一维数组中的索引，使用 getGridNum 函数取邻居节点的指针，并将其加入邻居节点集合。
   - 如果当前节点不在最下方，即 currentY 小于 gridsize-1，则将下方邻居节点加入邻居节点集合。具体操作同上。
   - 如果当前节点不在最左侧，即 currentX 大于 0，则将左侧邻居节点加入邻居节点集合。具体操作同上。
   - 如果当前节点不在最右侧，即 currentX 小于 gridsize-1，则将右侧邻居节点加入邻居节点集合。具体操作同上。最后返回邻居节点集合。

5. showRoute 函数
   函数用来将求得的路径显示出来，需要传入的参数有一个 cv::Mat 类型的图像引用 img，表示图像将要被修改；参数 gridsize 和 cellsize，网格的大小和每个单元格的大小；包含 GridCell 对象的向量 grids，包含并表示整个网格地图；一个包含指向 GridCell 对象的指针的向量 route，表示路径的点集。
   先使用 range-based-for 循环遍历路径 route 中的每一个元素；对于非起点和终点的网格，调用 setRoute() 方法进行标记。画图部分论述类似 drawgrid 部分，使用 cv::rectangle 方法，而矩形的位置和大小由网格坐标和单元格大小计算而来，最后通过 cv::imshow 显示图像，并通过 cv::waitKey 保持显示，用来模拟动态展示路径的生成过程。
6. gridInit 函数
   函数用来初始化整个网格地图。
   我先使用 std::fill 函数将 grids 中的每个元素都用 GridCell() 进行初始化。这就可以在 grids 中创建了 gridsize \* gridsize 个 GridCell 对象，并且这些对象的初始状态都是相同的，便于后续进行操作。
   使用两层嵌套的循环，遍历整个网格。对于每个网格，调用 getGridNum 函数获取在一维向量中的索引，并通过这个索引找到对应的 GridCell 对象。对该 GridCell 对象调用 setIndex 方法，将当前网格的二维坐标 (i, j) 设置为该对象的索引，因为索引值和建立的向量有关系的，需要单独进行初始化，其他的直接调用类的构造函数就可以处理。
7. generateObstacles 函数
   函数用于随机生成障碍物，相当于随机地图的功能。
   使用嵌套的循环遍历整个网格地图。对于每个网格，通过 rand() % 100 生成一个介于 0 到 99 之间的随机数。如果该随机数小于 25，即约有 25% 的概率，将当前网格标记为障碍物。这是通过调用 setBlock(true) 方法来实现的。
8. drawGrid 函数
   将初始化的网格画出来，同时加上分割线便于区分。

   - 使用两个嵌套的循环遍历整个网格。根据每个格子的类型，使用 cv::rectangle 画矩形，填充颜色不同。
     - 如果是障碍物格子，用深紫蓝色填充。
     - 如果是终点格子，用绿色填充。
     - 如果是起点格子，用红色填充。
     - 如果是路径格子，用棕色填充。
   - 使用循环在图像上绘制网格线，颜色为黑色，线宽为 2。
     垂直线通过 cv::Point(i _ cell_size, 0) 和 cv::Point(i _ cell*size, image_size) 定义；水平线通过 cv::Point(0, i * cell*size) 和 cv::Point(image_size, i * cell_size) 定义。

9. GridCell::setCost4Way 函数
   GridCell 类中用于设置网格代价的函数，使用了曼哈顿距离进行计算实现。
   如果当前网格是起始网格，将其 GCost 设置为 0。如果不是起始网格，将其 GCost 设置为其父节点的 GCost 加 1。然后用类中的 getIndex() 方法获取目标网格的坐标，跟着计算当前网格到目标网格的曼哈顿距离，并将结果赋值给 HCost，最后将 GCost 和 HCost 相加，得到 FCost。
10. AddAllRouteGridToVector 函数
    - 函数功能是将求出的路径点放在向量中，用于后续将路径点进行表示后显示。
      - 如果当前网格 grid 存在父节点（即不是起点），则执行以下操作：
      - 将当前网格 grid 加入到结果向量 result 中。
      - 通过递归调用 AddAllRouteGridToVector，继续处理父节点，实现向上回溯，直到父节点为空（相当于向上查找路径，从数据结构可以看出来）。
      - 如果当前网格没有父节点，即为路径的起点，直接返回（退出）。

# 四、结果分析

为了让计时功能比较明显，设置了格子数为 64\*64，寻路时间能达到 10ms 左右，太小可能小于 1ms，现象不明显。 1.现象描述
首先我手动生成了一个简单的回环迷宫，用于测试是否能寻路成功，效果图如下

可见能成功找到终点并把路径显示出来，本程序中的 A\*算法伪代码如下

- 开启队列 // 需要计算的节点的队列
- 已计算队列 // 已经被计算过的节点的队列
- 将开始点加入开启队列
- 在开始队列不为空的时候 循环
  - 当前节点 = 开始队列中 F Cost 最小的节点，如果相同则选择 H Cost 最小的，如果都一样则随意选择
  - 从开启队列中移除当前节点
  - 将当前节点加入已计算队列
  - 如果当前节点是目标点
    - 返回 寻路成功
  - 对于当前节点的每个邻居节点
    - 如果此邻居节点不可通过或者在已计算队列内
      - 跳过该节点
    - 如果此邻居节点不在开启队列中或此路径的 G Cost 更短
      - 设置该节点的 Cost
      - 将该节点的父节点设置为当前节点
      - 如果此邻居节点不在开启队列中
        - 将此节点加入开启队列
- 返回 寻路失败
  最终能将路径周围各个的结点的 fcost，gcost，hcost 算出来，我们也可以从调试面板中对 grids 进行监视可以看出来，由于程序没有编写可视化的 cost 显示，只能从调试窗口中查看，如下。

1. 算法描述
   fCost 是从初始状态经由状态 n 到目标状态的代价估计， gCost 是在状态空间中从初始状态到状态 n 的实际代价， hCost 是从状态 n 到目标状态的最佳路径的估计代价。
   先计算 gcost，例如，选择夹着一个位置，从 A 到该格子是横向移动，单步移动距离为 10，故 g = 10。
   再估计代价 h。它估计的含义是指忽略剩下的路径是否包含有障碍物（不可走）， 完全按照 Manhattan 计算方式，计算只做横向或纵向移动的累积代价：横向向右移动 3 步，纵向向上移动 1 步，总共 4 步，故为 h = 40.因此从 A 节点移动至 I 节点的总移动代价为： f = g + h = 50。以此类推，将该点剩下的都计算出来，最后选取 f 最小的放到 closelist 里面，并且注意的是，不同方向的 h 和 gcost 是不同的，比如向着终点的 cost 会小一些，这就让其 fcost 比较唯一。引用https://www.redblobgames.com/pathfinding/a-star/introduction.html 的图进行形象的说明。

   箭头方向是移动方向，这里虽然反映的是反向路径，但是也是类似的。下图更好的描述了该过程。

2. 功能描述
   （1）自定义地图和终点起点
   能将下面的地图左上角，通过鼠标点击变成下下图

   终点起点可以通过点击鼠标确定

   （2）地图大小定义
   修改此处定义

   可实现大小变化，同时能正常工作

   （3）用时显示

   （4）寻路失败处理
